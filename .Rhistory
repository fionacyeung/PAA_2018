load("C:/UCLA/thesis_ideas/PhD_thesis/one_to_one_verification/.RData")
1+8
matrix(c(1,2,3,4,5,6,7,8,9),nrow=3) %*% t(matrix(c(1,2,3,4,5,6,7,8,9),nrow=3))
matrix(c(1,2,3,4,5,6),nrow=2) %*% t(matrix(c(1,2,3,4,5,6),nrow=2))
install.packages("plotly")
library(plotly)
library(plotly)
trace_0 <- rnorm(100, mean = 5)
trace_1 <- rnorm(100, mean = 0)
trace_2 <- rnorm(100, mean = -5)
x <- c(1:100)
data <- data.frame(x, trace_0, trace_1, trace_2)
p <- plot_ly(data, x = ~x) %>%
add_trace(y = ~trace_0, name = 'trace 0',mode = 'lines') %>%
add_trace(y = ~trace_1, name = 'trace 1', mode = 'lines+markers') %>%
add_trace(y = ~trace_2, name = 'trace 2', mode = 'markers')
print(p)
getOption("repos")
options(repos = c(CRAN = "https://cran.rstudio.com"))
install.packages("stringi")
install.packages("stringi")
install.packages("installr");
require(installr)
updateR()
install.packages("installr");
install.packages("installr",lib='C:/Users/Daisy/Documents/R/win-library/3.5');
formula = choice ~ pf + cl + loc + wk + tod + seas | 0 | 0 | 0 | 1
MUtils = matrix(c(0.3,0.2,0.1,0.2,0.3,0.1), ncol=2)
WUtils = matrix(c(0.3,0.2,0.3,0.2,0.3,0.2), ncol=3)
studentUtils = WUtils
collegeUtils = MUtils
slots = c(1,2)
studentOptimal = FALSE
args = galeShapley.validate(collegeUtils, studentUtils, collegePref, studentPref)
library(matchingR)
args = galeShapley.validate(collegeUtils, studentUtils, collegePref, studentPref)
args = galeShapley.validate(collegeUtils, studentUtils, NULL, NULL)
args$proposerUtils
args$reviewerUtils
number_of_students = NROW(args$proposerUtils)
# number of colleges
number_of_colleges = NCOL(args$proposerUtils)
number_of_students
if(length(slots)==1) {
slots = rep(slots, number_of_colleges)
}
proposerUtils = repcol(args$proposerUtils, slots)
reviewerUtils = reprow(args$reviewerUtils, slots)
repcol = function(x, n){
s = NCOL(x)
if(length(n) == 1) {
return(matrix(x[,rep(1:s, each = n)], nrow = NROW(x), ncol = s*n))
}
matrix(x[,rep(1:s, n)], nrow = NROW(x), ncol = sum(n))
}
#' Repeat each row of a matrix n times
#'
#' This function repeats each row of a matrix n times
#'
#' @param x is the input matrix
#' @param n is the number of repetitions (can be a vector)
#' @return matrix with repeated rows
reprow = function(x, n){
s = NROW(x)
if(length(n) == 1) {
return(matrix(x[rep(1:s, each = n),], nrow = s*n, ncol = NCOL(x)))
}
matrix(x[rep(1:s, n),], nrow = sum(n), ncol = NCOL(x))
}
proposerUtils = repcol(args$proposerUtils, slots)
reviewerUtils = reprow(args$reviewerUtils, slots)
proposerUtils
reviewerUtils
proposerPref = sortIndex(as.matrix(proposerUtils));
proposerPref
res = cpp_wrapper_galeshapley(as.matrix(proposerPref), as.matrix(reviewerUtils))
str(res)
# number of slots
M = length(res$proposals)
# number of students
N = length(res$engagements)
res = c(res, list(
"unmatched.colleges" = rep(NA, length = sum(res$proposals == N)),
"unmatched.students" = seq(from = 0, to = N - 1)[res$engagements == M] + 1
))
unmatched.colleges = seq(from = 0, to = M - 1)[res$proposals == N] + 1
# assemble results
res$matched.colleges = list()
# map proposals back into slots
cumsum.slotsLower = cumsum(c(0, slots[-length(slots)]))+1
cumsum.slotsUpper = cumsum(slots)
for(jX in 1:number_of_colleges) {
# fill slots with student ids
res$matched.colleges[[jX]] = res$proposals[cumsum.slotsLower[jX]:cumsum.slotsUpper[jX]] + 1
# set vacant slots to NA
res$matched.colleges[[jX]][res$matched.colleges[[jX]] == (number_of_students + 1)] = NA
# unmatched colleges
res$unmatched.colleges[unmatched.colleges %in% (cumsum.slotsLower[jX]:cumsum.slotsUpper[jX])] = jX
}
str(res)
res$matched.students = matrix(NA, nrow = number_of_students, ncol=1)
for(jX in 1:number_of_colleges) {
res$matched.students[res$matched.colleges[[jX]]] = jX
}
str(res)
res$engagements = NULL
res$proposals = NULL
str(res)
galeShapley.checkStability = function(collegeUtils, studentUtils, res$proposals, res$engagements)
galeShapley.checkStability(collegeUtils, studentUtils, res$proposals, res$engagements)
results.collegeoptimal = galeShapley.collegeAdmissions(studentUtils = WUtils,
collegeUtils = MUtils,
slots = c(1,2),
studentOptimal = FALSE)
str(results.collegeoptimal)
galeShapley.checkStability(MUtils, WUtils, results.collegeoptimal$proposals, results.collegeoptimal$engagements)
ss=seq(0,1,by=0.01)
plot(ss,-ss^2)
plot(ss,ss^2)
plot(ss,ss^4)
plot(ss,ss^4-ss^2)
plot(ss,ss^2-ss^4)
plot(ss,ss^2+ss^4)
plot(ss,-ss^4)
plot(ss,ss*ss^2)
plot(ss,ss)
plot(ss,ss^2)
plot(ss,ss^2-ss)
plot(ss,ss^2+ss)
plot(ss,ss^(3/2)/ss)
load("C:\\UCLA\\thesis_ideas\\PhD_thesis\\latent_class_model\\LC_two_sided_sim_EM\\t_3_adj_llik_eq_marg_1_combined_eq_const\\Resultst_3_N_1000_wm_0.5_0.5_1.0_1.0_0.5_0.5")
load("C:\\UCLA\\thesis_ideas\\PhD_thesis\\latent_class_model\\LC_two_sided_sim_EM\\t_3_adj_llik_eq_marg_1_combined_eq_const\\Resultst_3_N_1000_wm_0.5_0.5_1.0_1.0_0.5_0.5.RData")
View(data_w)
View(X_m)
load("C:\\UCLA\\thesis_ideas\\PhD_thesis\\latent_class_model\\LC_two_sided_sim_EM\\Results_B200_N200_Q2_all_0.5_0.5_1.0.RData")
print("W: median:")
print(apply(params_all_w[,1:(num_beta*Q)], 2, median, na.rm=T))
print("W: mean:")
print(apply(params_all_w[,1:(num_beta*Q)], 2, mean, na.rm=T))
print("W: SD:")
print(apply(params_all_w[,1:(num_beta*Q)], 2, sd, na.rm=T))
print("M: median:")
print(apply(params_all_m[,1:(num_beta*Q)], 2, median, na.rm=T))
print("M: mean:")
print(apply(params_all_m[,1:(num_beta*Q)], 2, mean, na.rm=T))
print("M: SD:")
print(apply(params_all_m[,1:(num_beta*Q)], 2, sd, na.rm=T))
setwd("C:\\UCLA\\thesis_ideas\\PhD_thesis\\latent_class_model\\LC_two_sided_sim_EM")
setwd("C:\\UCLA\\thesis_ideas\\PhD_thesis\\latent_class_model\\misspecified_many_cleaned_up_works_gw_gm_individuals")
source("one_to_one_matching_CP.R")
sum(pmfj$pmfj_est)
sum(pmfj$pmfj_est[1:2,1:2])
sum(pmfj$pmfj_obs[1:2,1:2])
pmfj$pmfj_obs[1:2,1:2]*2
pmfj$pmfj_est[1:2,1:2]*2
pmfj$pmfj_obs[1:2,1:2]
0.3724999*2
sum(pmfj$pmfj_est[1:2,1:2]*2)
setwd("C:\\UCLA\\research_projects\\PAA_2018")
source("one_to_one_matching_CP.R")
class(mu)
mu2=Matrix(mu)
class(mu2)
source("one_to_one_matching_CP.R")
sum(pmfj$pmfj_est)
sum(pmfj$pmfj_obs)
sum(pmfj$pmfj_obs[1:2,1:2])
sum(pmfj$pmfj_est[1:2,1:2])
source("one_to_one_matching_CP.R")
source("one_to_one_matching_CP.R")
source("one_to_one_matching_CP.R")
source("one_to_one_matching_CP.R")
source("one_to_one_matching_CP.R")
apply(mu,1,function(x)which(x==1))
source("one_to_one_matching_CP.R")
sum(pmfj$pmfj_est)
sum(pmfj$pmfj_obs)
sum(pmfj$pmfj_obs[1:2,1:2])
sum(pmfj$pmfj_est[1:2,1:2])
apply(mu,1,function(x)which(x==1))
log(nrow(Xdata)/n)
nrow(Xdata)/n
source("one_to_one_matching_CP.R")
exp(gw)
View(U_star)
View(V_star)
View(U)
View(zeta)
rnorm(10)
set.seed(1234)
rnorm(5)
source("one_to_one_matching_CP.R")
source("one_to_one_matching_CP.R")
source("one_to_one_matching_CP.R")
source("one_to_one_matching_CP.R")
